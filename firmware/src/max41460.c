#include "gpio.h"
#include "max41460.h"
#include <util/delay.h> // for waiting


void configSPI() {
	// config SPI pins
	READER_PORT.DIRSET = SPI_MOSI | SPI_SCK | SPI_CS;
	READER_PORT.OUTSET = SPI_CS;
	// configure SPI
	// select master mode, divide clock, enable
	SPI0.CTRLA = SPI_MASTER_bm | SPI_PRESC_DIV16_gc | SPI_ENABLE_bm;
}

uint8_t transferSPI(uint8_t byte) {
	SPI0.DATA = byte;
	while (!(SPI0.INTFLAGS & SPI_IF_bm)); // wait until data is exchanged
	return SPI0.DATA;
}

void startTransmitter() {
	/*
	After turning on power supply (or after a soft reset), an SPI transaction that burst-writes 17 consecutive registers from
	address 0x00 to 0x10 is required to initialize the PLL frequency synthesizer.
	The initial programming must clear MODMODE (register CFG1, address 0x00, bit0), clear SPI_TXEN1 (register CFG6,
	address 0x0A, bit1), configure FREQ[23:0] (register PLL3, PLL4 and PLL5) to desired frequency, and set SPI_TXEN2
	(register CFG7, address 0x10, bit1).
	With this process there are two timing requirements:
	1) From transaction start to the SPI_TXEN bitwrite, the time lag must be longer than the XO turn-ontime (tXO).
	2) From SPI_TXEN bit write to transaction end, the time lag must be longer than the PLL turn-ontime (tPLL)

	The event trigger of data transmission is a rising edge on SPI_TXEN, which is a special register bit with
	two aliases SPI_TXEN1 (register CFG6, 0x0A, bit 1) and SPI_TXEN2 (register CFG7, 0x10, bit 1). A rising edge on
	SPI_TXEN can be generated by clearing SPI_TXEN1 and setting SPI_TXEN2 in a single SPI transaction.

	For example, the crystal frequency is 16MHz, the RF frequency is 315MHz, the 17 consecutive registers can be
	configured as:
	[0x90, 0x81, 0x03, 0x00, 0x00, 0x04, 0x80, 0x80, 0x60, 0x00, 0x00, 0xC4, 0xDE, 0x98, 0x28, 0x04, 0x02].
	*/
	const uint8_t boostPA = 1; // set to 1 to enable PA output power up to 16 dBm with proper matching network
	const uint8_t drivers = 8; // number of parallel drivers in the PA (1...8)
	const uint8_t caps = 0; // number of parallel 175 fF capacitors on PA output (0...31)

	const float centerFreq = 866.3;
	const float crystalFreq = 16.0;
	const uint32_t freq = (uint32_t)(((1 << 16) * centerFreq) / crystalFreq);

	READER_PORT.OUTCLR = SPI_CS;
	_delay_us(250+100); // wait for crystal oscillator and PLL to turn on
	transferSPI(0x00 & 0x7F); // send write mode (bit 7 cleared) and start address (0x00)
	const uint8_t data[] = {
		0x90, // CFG1 (0x00), reset value
		0x81, // CFG2 (0x01), reset value
		0x03, // CFG3 (0x02), reset value
		0x02, // CFG4 (0x03), fast wake-up power-down mode. Set 0x00 for default
		0x00, // CFG5 (0x04), reset value
		0x04 | boostPA, // SHDN (0x05), reset value + PA boost
		0x80 | (drivers-1), // PA1 (0x06), reset value + drivers
		caps, // PA2 (0x07), parallel capacitance
		0x60, // PLL1 (0x08), reset value
		0x00, // PLL2 (0x09), reset value
		0x00, // CFG6 (0x0A), reset value (+ 0x01 to enable 4-wire SPI mode to read back values with MISO)
		(uint8_t)(freq >> 16), // PLL3 (0x0B), frequency [23:16]
		(uint8_t)(freq >> 8), // PLL4 (0x0C), frequency [15:8]
		(uint8_t)(freq), // PLL5 (0x0D), frequency [7:0]
		0x28, // PLL6 (0x0E), reset value
		0x04, // PLL7 (0x0F), reset value
		0x02 // CFG7 (0x10), reset value + (enable TX << 1)
	};
	for (uint8_t i = 0; i < sizeof(data); i++) {
		transferSPI(data[i]);
	}
	_delay_us(10); // wait for tx

	// release SPI control over MOSI / data pin
	SPI0.CTRLA &= ~SPI_ENABLE_bm;

	// should not be needed
	READER_PORT.DIRSET = SPI_CS;
	READER_PORT.OUTCLR = SPI_CS;
}